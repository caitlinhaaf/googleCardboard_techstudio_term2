<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Google Cardboard - Particle Effects</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        margin: 0px;
        overflow: hidden;
      }
      #webglviewer {
        bottom: 0;
        left: 0;
        position: absolute;
        right: 0;
        top: 0;
      }
    </style>
  </head>
  <body>
    <div id="webglviewer"></div>

    <script src="js/three.min.js"></script>
    <script src="js/StereoEffect.js"></script>
    <script src="js/GPUParticleSystem.js" charset="utf-8"></script>

    <!-- THREE JS CONTROLS  -->
    <script src="js/controls/DeviceOrientationControls.js"></script>
    <script src="js/controls/OrbitControls.js"></script>

    <!-- THREE JS DESKTOP CONTROLS -->
    <!-- <script src="js/controls/TrackballControls.js"></script> -->

    <script>
      var scene,
          camera,
          renderer,
          element,
          container,
          effect,
          controls,
          clock = new THREE.Clock(true),

          tick = 0,
          options,
          spawnerOptions,
    			particleSystem,
          effect,

          // Particles
          particles = new THREE.Object3D(),
          totalParticles = 200,
          maxParticleSize = 200,
          particleRotationSpeed = 0,
          particleRotationDeg = 0,
          lastColorRange = [0, 0.3],
          currentColorRange = [0, 0.3];

      init();
      // animate();

      //INIT FUNCTION
      //------------------------
      function init() {
        // CAMERA SETUP
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.001, 700);
        camera.position.set(0, 15, 0);
        scene.add(camera);

        //RENDERER SETUP
        renderer = new THREE.WebGLRenderer();

        // click to make fullscreen
        // renderer.domElement.addEventListener( 'click', function () {
				// 	if ( this.requestFullscreen ) {
				// 		this.requestFullscreen();
				// 	} else if ( this.msRequestFullscreen ) {
				// 		this.msRequestFullscreen();
				// 	} else if ( this.mozRequestFullScreen ) {
				// 		this.mozRequestFullScreen();
				// 	} else if ( this.webkitRequestFullscreen ) {
				// 		this.webkitRequestFullscreen();
				// 	}
				// } );

        element = renderer.domElement;
        container = document.getElementById('webglviewer');
        container.appendChild(element);

        // STEREO EFFECT
        effect = new THREE.StereoEffect(renderer);

        // ORBIT CONTROLS
        // Our initial control fallback with mouse/touch events in case DeviceOrientation is not enabled
        controls = new THREE.OrbitControls(camera, element);
        controls.target.set(
          camera.position.x + 0.15,
          camera.position.y,
          camera.position.z
        );
        controls.noPan = true;
        controls.noZoom = true;
        // Our preferred controls via DeviceOrientation
        function setOrientationControls(e) {
          if (!e.alpha) {
            return;
          }
          controls = new THREE.DeviceOrientationControls(camera, true);
          controls.connect();
          controls.update();

          element.addEventListener('click', fullscreen, false);

          window.removeEventListener('deviceorientation', setOrientationControls, true);
        }
        window.addEventListener('deviceorientation', setOrientationControls, true);



        //PARTICLE SYSTEM
				particleSystem = new THREE.GPUParticleSystem({
					maxParticles: 2500000
				});
				scene.add(Â particleSystem);
				// options passed during each spawned
				options = {
					position: new THREE.Vector3(),
					positionRandomness: .8,
					velocity: new THREE.Vector3(),
					velocityRandomness: .5,
					color: 0xaa88ff,
					colorRandomness: .2,
					turbulence: .5,
					lifetime: 2,
					size: 1,
					sizeRandomness: 3
				};
				spawnerOptions = {
					spawnRate: 15000,
					horizontalSpeed: 1,
					verticalSpeed: 5,
					timeScale: 1
				}




        // Lighting
        var light = new THREE.PointLight(0x999999, 2, 100);
        light.position.set(50, 50, 50);
        scene.add(light);

        var lightScene = new THREE.PointLight(0x999999, 2, 100);
        lightScene.position.set(0, 5, 0);
        scene.add(lightScene);

        // var floorTexture = THREE.ImageUtils.loadTexture('textures/wood.jpg');
        // floorTexture.wrapS = THREE.RepeatWrapping;
        // floorTexture.wrapT = THREE.RepeatWrapping;
        // floorTexture.repeat = new THREE.Vector2(50, 50);
        // floorTexture.anisotropy = renderer.getMaxAnisotropy();

        var floorMaterial = new THREE.MeshPhongMaterial({
          color: 0x000000,
          specular: 0x000000,
          shininess: 20,
          shading: THREE.FlatShading,
        //   map: floorTexture
        });

        var geometry = new THREE.PlaneBufferGeometry(1000, 1000);

        var floor = new THREE.Mesh(geometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        // scene.add(floor);

        var particleTexture = THREE.ImageUtils.loadTexture('textures/particle4u.png'),
            spriteMaterial = new THREE.SpriteMaterial({
            map: particleTexture,
            color: 0xffffff
          });

        for (var i = 0; i < totalParticles; i++) {
          var sprite = new THREE.Sprite(spriteMaterial);

          sprite.scale.set(64, 64, 1.0);
          sprite.position.set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.75);
          sprite.position.setLength(maxParticleSize * Math.random());

          sprite.material.blending = THREE.AdditiveBlending;

          particles.add(sprite);
        }
        particles.position.y = 70;
        scene.add(particles);

        animate();
      }



      // ANIMATE FUNCTION
      //------------------------
      function animate() {
        requestAnimationFrame(animate);
        controls.update();

        var delta = clock.getDelta() * spawnerOptions.timeScale;
				tick += delta;

				if (tick < 0) tick = 0;

				if (delta > 0) {
					options.position.x = Math.sin(tick * spawnerOptions.horizontalSpeed) * 20;
					options.position.y = Math.sin(tick * spawnerOptions.verticalSpeed) * 10;
					options.position.z = Math.sin(tick * spawnerOptions.horizontalSpeed + spawnerOptions.verticalSpeed) * 5;

					for (var x = 0; x < spawnerOptions.spawnRate * delta; x++) {
						// Yep, that's really it.	Spawning particles is super cheap, and once you spawn them, the rest of
						// their lifecycle is handled entirely on the GPU, driven by a time uniform updated below
						particleSystem.spawnParticle(options);
					}
				}

				particleSystem.update(tick);



        var elapsedSeconds = clock.getElapsedTime(),
            particleRotationDirection = particleRotationDeg <= 180 ? -1 : 1;

        particles.rotation.y = elapsedSeconds * particleRotationSpeed * particleRotationDirection;

        // We check if the color range has changed, if so, we'll change the colours
        if (lastColorRange[0] != currentColorRange[0] && lastColorRange[1] != currentColorRange[1]) {

          for (var i = 0; i < totalParticles; i++) {
            particles.children[i].material.color.setHSL(currentColorRange[0], currentColorRange[1], (Math.random() * (0.7 - 0.2) + 0.2));
          }

          lastColorRange = currentColorRange;
        }

        update(clock.getDelta());
        render(clock.getDelta());


      }






      function resize() {
        var width = container.offsetWidth;
        var height = container.offsetHeight;

        camera.aspect = width / height;
        camera.updateProjectionMatrix();

        renderer.setSize(width, height);
        effect.setSize(width, height);
      }

      function update(dt) {
        resize();

        camera.updateProjectionMatrix();

        controls.update(dt);
        effect.render( scene, camera );
      }

      function render(dt) {
        effect.render(scene, camera);
      }

      function fullscreen() {
        if (container.requestFullscreen) {
          container.requestFullscreen();
        } else if (container.msRequestFullscreen) {
          container.msRequestFullscreen();
        } else if (container.mozRequestFullScreen) {
          container.mozRequestFullScreen();
        } else if (container.webkitRequestFullscreen) {
          container.webkitRequestFullscreen();
        }
      }

      function getURL(url, callback) {
        var xmlhttp = new XMLHttpRequest();

        xmlhttp.onreadystatechange = function() {
          if (xmlhttp.readyState == 4) {
             if (xmlhttp.status == 200){
                 callback(JSON.parse(xmlhttp.responseText));
             }
             else {
                 console.log('We had an error, status code: ', xmlhttp.status);
             }
          }
        }

        xmlhttp.open('GET', url, true);
        xmlhttp.send();
      }
    </script>
  </body>
</html>
